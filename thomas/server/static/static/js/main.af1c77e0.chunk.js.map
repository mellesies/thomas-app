{"version":3,"sources":["header/index.js","footer/index.js","network/node.js","_api/index.js","network/index.js","App.js","config.js","serviceWorker.js","index.js"],"names":["Header","onChange","event","props","onNetworkSelected","target","value","this","networks","map","n","key","id","name","className","href","renderOptions","Component","Footer","Node","onDragMove","e","x","y","setPosition","RV","onDragEnd","onStateToggled","state","node","titleHeight","stateOffset","stateHeight","statePadding","width","height","computeHeight","position","probabilities","query","remaining_width","states","idx","probability","bar_width","bar_color","toFixed","onDblClick","text","padding","fontSize","wrap","ellipsis","fill","align","length","center","corners","createStates","draggable","cornerRadius","shadowBlur","fontStyle","api","_axios","_user","config","_config","axios","create","interceptors","request","use","headers","localStorage","getItem","createAuthRefreshInterceptor","failedRequest","refreshAuthLogic","_conifg","post","then","tokenRefreshResponse","token","access_token","data","setItem","response","Promise","resolve","console","log","r","_request","url","method","network","parameters","Edge","src","dst","points","pointerLength","pointerWidth","stroke","strokeWidth","getNodeNamesFromNetwork","nodes","intersect","x1","y1","x2","y2","x3","y3","x4","y4","warn","denominator","ua","ub","compute_intersection","line","intersection","p","key1","key2","Network","onNodeMove","nodeAttrsToState","onNodeMoved","network_id","saveNetwork","q","first_pass_complete","node_centers","node_corners","myRefs","queryNetwork","setState","nodenames","current","srcRV","dstRV","src_center","dst_center","src_corners","dst_corners","edges","computeEdge","reduce","a","renderEdges","React","createRef","ref","Comment","App","getNetwork","json","getNetworks","api_config","process","REACT_APP_BASEURL","Boolean","window","location","hostname","match","init","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.af1c77e0.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nimport './stylesheet.scss';\n\nexport default class Header extends Component {\n\n    onChange = (event) => {\n        // console.log(\"Header::onChange(): \", event.target.value);\n        this.props.onNetworkSelected(event.target.value);\n    }\n\n    renderOptions() {\n        return this.props.networks.map(n =>\n            <option key={n.id} value={n.id}>\n                {n.name}\n            </option>\n        );\n    }\n\n    render() {\n        return (\n            <div className=\"Header\">\n                <div className=\"top\">\n                    <div className=\"left\">\n                        <span className=\"h1\">Thomas</span>\n                        &nbsp; A Bayesian Network viewer.\n                    </div>\n\n                    <div className=\"right\">\n                        <a href=\"https://github.com/mellesies/thomas-app\">\n                            Github\n                        </a>\n                    </div>\n                </div>\n\n                <select onChange={this.onChange}>\n                    { this.renderOptions() }\n                </select>\n            </div>\n        );\n    }\n}","import React, { Component } from 'react';\n\nimport './stylesheet.scss';\n\nexport default class Footer extends Component {\n\n\n    render() {\n        return (\n            <div className=\"Footer\">\n                Copyright © 2020 Melle Sieswerda. All rights reserved.\n            </div>\n        );\n    }\n}","import React, { Component } from 'react';\nimport {\n    Group,\n    Rect,\n    Label,\n    Tag,\n    Text,\n} from 'react-konva';\n\nexport default class Node extends Component {\n\n    constructor(props) {\n        super(props);\n        this.RV = props.node.RV;\n\n        this.titleHeight = 15\n        this.stateOffset = 8\n        this.stateHeight = 14\n        this.statePadding = 2;\n\n        this.width = 180;\n        this.height = this.computeHeight();\n\n        const\n            x = props.node.position[0],\n            y = props.node.position[1];\n\n        // this requires height to be computed and sets:\n        //  - this.x, this.y\n        //  - this.center\n        //  - this.corners\n        this.setPosition(x, y);\n    }\n\n    onDragMove = (e) => {\n        const\n            x = e.target.x(),\n            y = e.target.y();\n\n        // console.log('onDragMove:', x, y);\n        this.setPosition(x, y);\n\n        if (this.props.onDragMove) {\n            this.props.onDragMove(this.RV, x, y);\n        }\n    }\n\n    onDragEnd = (e) => {\n        const\n            x = e.target.x(),\n            y = e.target.y();\n\n        if (this.props.onDragEnd) {\n            this.props.onDragEnd(this.RV, x, y);\n        }\n    }\n\n    onStateToggled = (state) => {\n        // console.log(`onStateToggled('${state}')`);\n        if (this.props.onStateToggled) {\n            this.props.onStateToggled(this.RV, state)\n        }\n    }\n\n    /**\n     * Create Labels for the individual states.\n     */\n    createStates(node, probabilities, query) {\n        const { width } = this;\n        const\n            label_width = 70,\n            probability_width = 55;\n\n        const remaining_width = width - label_width - probability_width;\n\n        // console.log('createStates', query);\n\n        return node.states.map((state, idx) => {\n            const y = (\n                this.titleHeight\n                + this.stateOffset\n                + idx * this.stateHeight\n            )\n\n            var probability = '...';\n            var bar_width = 0;\n            var bar_color = '#003366';\n\n            if (query && query === state) {\n                bar_color = '#00BCCC';\n            }\n\n            if (probabilities) {\n                probability = (100 * probabilities[state]).toFixed(2) + '%';\n                bar_width = 1 + remaining_width * probabilities[state]\n            }\n\n            return (\n                <Group\n                    key={state}\n                    y={y}\n                    onDblClick={e => this.onStateToggled(state)}\n                    >\n\n                    <Label>\n                        <Tag />\n                        <Text\n                            text={state}\n                            padding={this.statePadding}\n                            fontSize={this.stateHeight - this.statePadding}\n                            wrap=\"none\"\n                            ellipsis=\"ellipsis\"\n                            width={label_width}\n                            />\n                    </Label>\n\n                    <Rect\n                        x={label_width}\n                        y={1}\n                        width={bar_width}\n                        height={this.stateHeight - 2}\n                        fill={bar_color}\n                        />\n\n                    <Label x={width - probability_width}>\n                        <Tag />\n                        <Text\n                            text={probability}\n                            padding={this.statePadding}\n                            fontSize={this.stateHeight - this.statePadding}\n                            align=\"right\"\n                            wrap=\"none\"\n                            width={probability_width}\n                            />\n                    </Label>\n                </Group>\n            );\n        })\n    }\n\n\n    /**\n     * Compute and return the Node's height.\n     */\n    computeHeight() {\n        const { node } = this.props;\n\n        return (\n            node.states.length * this.stateHeight\n            + 2 * this.stateOffset\n            + this.titleHeight\n        );\n    }\n\n    /**\n     * Recompute center and corners.\n     *\n     * @param x (int): new x (top-left corner)\n     * @param y (int): new y (top-left corner)\n     */\n    setPosition(x, y) {\n        // console.log(`setPosition(${x}, ${y})`)\n        const { width, height } = this;\n\n        this.x = x;\n        this.y = y\n\n        this.center = {\n            x: x + width/2,\n            y: y + height/2\n        }\n\n        this.corners = {\n            'tl': {x: x, y: y},\n            'tr': {x: x + width, y: y},\n            'bl': {x: x, y: y + height},\n            'br': {x: x + width, y: y + height},\n        }\n    }\n\n    render() {\n        const { node, query, probabilities } = this.props;\n        const { x, y, width, height } = this;\n        const states = this.createStates(node, probabilities, query);\n\n        // Return the Node as a group.\n        return (\n            <Group\n                x={x}\n                y={y}\n                width={width}\n                height={height}\n                onDragMove={this.onDragMove}\n                onDragEnd={this.onDragEnd}\n                // onDblClick={(e) => console.log('onDblClick')}\n                draggable\n                >\n                {/* Background */}\n                <Rect\n                    fill=\"#efefef\"\n                    width={width}\n                    height={height}\n                    cornerRadius={5}\n                    shadowBlur={5}\n                    />\n\n                {/* Header */}\n                <Label>\n                    <Tag />\n                    <Text\n                        text={node.name}\n                        padding={4}\n                        fontSize={this.titleHeight}\n                        fontStyle=\"bold\"\n                        width={width}\n                        />\n                </Label>\n\n                {/* States */}\n                { states }\n            </Group>\n        )\n    }\n}","import axios from 'axios';\nimport createAuthRefreshInterceptor from 'axios-auth-refresh';\n\nconst getAccessToken = () => {\n    return localStorage.getItem('access_token');\n}\n\nconst setAccessToken = (token) => {\n    localStorage.setItem('access_token', token);\n}\n\n\nclass Api {\n    constructor() {\n        this._axios = null;\n        this._user = false; }\n\n    /**\n     * Initialize the API.\n     */\n    init(config) {\n        // Setup axios to use JWT and automatically refresh if necessary.\n        this._config = config;\n        this._axios = axios.create(config);\n\n        this._axios.interceptors.request.use(request => {\n            request.headers['Authorization'] = 'Bearer ' + getAccessToken();\n            return request;\n        });\n\n        createAuthRefreshInterceptor(\n            this._axios,\n            (failedRequest) => this.refreshAuthLogic(failedRequest)\n        );\n\n        // Make axios.request available for flexibility\n        this.request = this._axios.request;\n    }\n\n    // Function that will be called to refresh authorization\n    refreshAuthLogic(failedRequest) {\n        axios.create(this._conifg).post('/token/refresh')\n        .then(tokenRefreshResponse => {\n            const { access_token } = tokenRefreshResponse.data;\n            setAccessToken(access_token);\n\n            const { headers } = failedRequest.response.config;\n            headers['Authorization'] = `Bearer ${access_token}`;\n\n            return Promise.resolve();\n        })\n    }\n\n    _request(config) {\n        console.log('Api::request()', config);\n        return this._axios.request(config).then(r => r.data);\n    }\n\n    /**\n     * Return the API version\n     */\n    getVersion() {\n        return this._request({\n            url: '/version',\n            method: 'GET',\n        });\n    }\n\n    getNetworks() {\n        console.log('Api::getNetworks()', );\n\n        return this._request({\n            url: '/network',\n            method: 'GET',\n        });\n    }\n\n    getNetwork(id) {\n        return this._request({\n            url: `/network/${id}`,\n            method: 'GET',\n        });\n    }\n\n    saveNetwork(id, network) {\n        return this._request({\n            url: `/network/${id}`,\n            method: 'POST',\n            data: network,\n        });\n    }\n\n    queryNetwork(id, parameters) {\n        var query = {\n            id: id,\n            query: {\n                ...parameters\n            }\n        };\n\n        return this._request({\n            url: `/network/_query`,\n            // params: parameters,\n            data: query,\n            method: 'POST',\n        })\n    }\n}\n\nexport const api = new Api();\nexport default api;","import React, { Component } from 'react';\nimport {\n    Stage, Layer,\n    Arrow,\n} from 'react-konva';\n\nimport Node from './node';\nimport { api } from '_api';\n\nimport './stylesheet.scss';\n\n\nfunction Edge({src, dst}) {\n    return (\n        <Arrow\n            x={0}\n            y={0}\n            points={[src.x, src.y, dst.x, dst.y]}\n            pointerLength={10}\n            pointerWidth={10}\n            fill={'black'}\n            stroke={'black'}\n            strokeWidth={2}\n            />\n    )\n}\n\nfunction getNodeNamesFromNetwork(network) {\n    return network.nodes.map(node => node.RV);\n}\n\n// line intercept math by Paul Bourke http://paulbourke.net/geometry/pointlineplane/\n// Determine the intersection point of two line segments\n// Return FALSE if the lines don't intersect\n// Alternative implementations at:\n// - http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n// - https://stackoverflow.com/questions/13937782/calculating-the-point-of-intersection-of-two-lines\n//\nfunction intersect(x1, y1, x2, y2, x3, y3, x4, y4) {\n\n    // Check if none of the lines are of length 0\n    if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n        console.warn('Found line of length 0');\n        return false\n    }\n\n    var denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))\n\n    // Lines are parallel\n    if (denominator === 0) {\n        console.warn('Denominator is zero 0');\n        return false\n    }\n\n    let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator\n    let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator\n\n    // is the intersection along the segments\n    if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n        // console.debug('Intersection outside segments');\n        return false\n    }\n\n    // Return an object with the x and y coordinates of the intersection\n    let x = x1 + ua * (x2 - x1)\n    let y = y1 + ua * (y2 - y1)\n\n    return {x, y}\n}\n\nfunction compute_intersection(corners, line) {\n    const points = [\n        ['tl', 'tr'],\n        ['tl', 'bl'],\n        ['tr', 'br'],\n        ['bl', 'br'],\n    ];\n\n    var intersection = false;\n\n    for (const p of points) {\n        const key1 = p[0], key2 = p[1];\n\n        intersection = intersect(\n            corners[key1].x,\n            corners[key1].y,\n            corners[key2].x,\n            corners[key2].y,\n            line.src.x,\n            line.src.y,\n            line.dst.x,\n            line.dst.y,\n        );\n\n        if (intersection) {\n            break;\n        }\n    }\n\n    if (!intersection) {\n        console.warn('Could not determine intersection');\n    }\n\n    return intersection;\n}\n\nexport default class Network extends Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            first_pass_complete: false,\n            node_centers: {},\n            node_corners: {},\n            query: {},\n            probabilities: {},\n        }\n\n        this.myRefs = {};\n    }\n\n    componentDidMount() {\n        // When componentDidMount gets calleed, this.myRefs is set and each\n        // ref.current points to a <Node>\n        this.nodeAttrsToState();\n        this.query({});\n    }\n\n    query(query) {\n        // console.log('Network::query()', query);\n        const id = this.props.network.id;\n\n        api.queryNetwork(id, query).then(r => {\n            // console.log('Network::query(): ', r)\n            this.setState({\n                query: r.query,\n                probabilities: r.probabilities,\n            })\n        })\n\n    }\n\n    /**\n     * Iterate over <Node>'s rendered and retrieve their corners and centers.\n     */\n    nodeAttrsToState() {\n        const nodenames = getNodeNamesFromNetwork(this.props.network);\n        const\n            node_centers = {},\n            node_corners = {};\n\n        for (const name of nodenames) {\n            var node = this.myRefs[name].current;\n\n            // node.center and node.corners are set in Node.render()\n            node_centers[name] = node.center;\n            node_corners[name] = node.corners;\n        }\n\n        this.setState({\n            first_pass_complete: true,\n            node_centers,\n            node_corners,\n        });\n    }\n\n    /**\n     * Return the line (coordinates) between two nodes' centers, taking the\n     * nodes' edges into account.\n     */\n    computeEdge(srcRV, dstRV) {\n        const { node_centers, node_corners } = this.state;\n\n        const\n            src_center = node_centers[srcRV],\n            dst_center = node_centers[dstRV];\n\n        const\n            src_corners = node_corners[srcRV],\n            dst_corners = node_corners[dstRV];\n\n        const src_intersection = compute_intersection(\n            src_corners,\n            {src: src_center, dst: dst_center}\n        );\n\n        const dst_intersection = compute_intersection(\n            dst_corners,\n            {src: src_center, dst: dst_center}\n        );\n\n        return {\n            src: src_intersection,\n            dst: dst_intersection,\n        }\n    }\n\n    /**\n     * Triggered by Node for each update to its position.\n     */\n    onNodeMove = (RV, x, y) => {\n        // console.log('Network::onNodeMove()', RV);\n        this.nodeAttrsToState();\n    }\n\n    /**\n     * Triggered by Node after dragging has stopped.\n     */\n    onNodeMoved = (RV, x, y) => {\n        // console.log(`Network::onNodeMoved('${RV}', ${x}, ${y})`);\n        const network = { ...this.props.network };\n        const { network_id } = this.props;\n\n        for (const node of network.nodes) {\n            if (node.RV === RV) {\n                node.position = [x, y];\n                break\n            }\n        }\n\n        // Save the network.\n        api.saveNetwork(network_id, network);\n    }\n\n    onStateToggled = (RV, state) => {\n        // console.log(`onStateToggled('${RV}', '${state}')`);\n        const q = { ...this.state.query };\n\n        if (q[RV] && q[RV] === state) {\n            delete q[RV];\n        } else {\n            q[RV] = state;\n        }\n\n        this.query(q);\n    }\n\n    renderEdges() {\n        const { network } = this.props;\n\n        return network.edges.map(e => {\n            const\n                srcRV = e[0],\n                dstRV = e[1];\n\n            const {src, dst} = this.computeEdge(srcRV, dstRV);\n\n            // console.log('Creating Edge: src:', src, 'dst:', dst);\n            return (\n                <Edge\n                    key={`${srcRV}_${dstRV}`}\n                    src={src}\n                    dst={dst}\n                    />\n            )\n        })\n    }\n\n    render() {\n        const { network } = this.props;\n        const {\n            first_pass_complete,\n            query,\n            probabilities,\n        } = this.state;\n        const { myRefs } = this;\n\n        // Create an ordered list of node names\n        // const nodenames = network.nodes.map(node => node.RV);\n        const nodenames = getNodeNamesFromNetwork(network);\n\n        // Create a dict of nodes, indexed by node.RV\n        const nodes = network.nodes.reduce(\n            (a, node) => {\n                a[node.RV] = node;\n                return a;\n            },\n            {}\n        );\n\n        return (\n            <div className=\"Network\">\n                {/*<Toolbar network={network} />*/}\n\n                <div className=\"KonvaContainer\">\n                    <Stage width={2042} height={1024}>\n                        <Layer>\n                            {first_pass_complete && this.renderEdges()}\n\n                            {nodenames.map(RV => {\n                                // console.log('RV: ', RV, this);\n                                myRefs[RV] = React.createRef();\n\n                                return (\n                                    <Node\n                                        ref={myRefs[RV]}\n                                        key={RV}\n                                        node={nodes[RV]}\n                                        query={query[RV]}\n                                        probabilities={probabilities[RV]}\n                                        onDragMove={this.onNodeMove}\n                                        onDragEnd={this.onNodeMoved}\n                                        onStateToggled={this.onStateToggled}\n                                        />\n                                )\n                            })}\n                        </Layer>\n                    </Stage>\n                </div>\n            </div>\n        )\n    }\n}\n","import React, { Component } from 'react';\n\nimport Header from 'header';\nimport Footer from 'footer';\nimport Network from 'network';\nimport { api } from '_api';\n\nimport './App.scss';\n\n\nfunction Comment(props) {\n    // console.log(props.children);\n    return null;\n}\n\n\nexport default class App extends Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            networks: [],\n            network: null,\n        }\n    }\n\n    /**\n     * Triggered when dropdown list in Header changes.\n     */\n    onNetworkSelected = (network_id) => {\n        console.log(`network ${network_id} selected!`);\n\n        api.getNetwork(network_id).then((response) => {\n            var network = response.json;\n            network.id = network_id;\n\n            this.setState({\n                network_id,\n                network,\n            })\n        })\n    }\n\n    /**\n     * Called once after the component is created and has been attached to the\n     * DOM.\n     *\n     * Retrieves BNs from the server and updates state when complete.\n     */\n    componentDidMount() {\n        api.getNetworks().then(networks => {\n            console.log('App.componentDidMount(): ', networks);\n\n            if (networks.length > 0) {\n                this.setState(\n                    { networks },\n                    () => this.onNetworkSelected(networks[0].id)\n                );\n            }\n        });\n    }\n\n    render() {\n        var {\n            networks,\n            network_id,\n            network\n        } = this.state;\n\n        // console.log('App::render(): ', network);\n\n        return (\n            <div className=\"App\">\n                <Comment>Header that displays </Comment>\n\n                <Header\n                    networks={networks}\n                    onNetworkSelected={this.onNetworkSelected}\n                    />\n                { network === null &&\n                    <span>Loading ...</span>\n                }\n\n                {\n                    /*\n                        'key' is provided to force React to recreate the component\n                        when props change. See https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component\n                    */\n                    network &&\n                        <Network\n                            key={network.id}\n                            network_id={network_id}\n                            network={network}\n                            />\n                }\n                <Footer />\n            </div>\n        );\n    }\n}\n\n// export default App;\n","\n// API\nconst api_config = {};\n\nif (process.env.NODE_ENV === 'development') {\n    console.log('Running in development mode')\n    api_config['baseURL'] = 'http://localhost:5000';\n\n} else {\n    // console.log('Running in production mode')\n    api_config['baseURL'] = '';\n}\n\n// Environment variable always overrides\nif (process.env.REACT_APP_BASEURL) {\n    // console.log('Overriding \"api_config.baseURL\" with value from environment!');\n    api_config['baseURL'] = process.env.REACT_APP_BASEURL;\n}\n\n// console.log('api_config:', api_config);\nexport { api_config };\n\n// LOCALE\nexport const locale_config = {\n    language: '',\n    locale: '',\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport App from './App';\nimport { api } from '_api';\nimport { api_config } from 'config.js';\n\nimport * as serviceWorker from './serviceWorker';\n\n// console.log('api_config:', api_config);\n// console.log(config.api_url);\napi.init(api_config);\n\nReactDOM.render(\n    <App />,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}